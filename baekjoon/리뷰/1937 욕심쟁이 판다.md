## 초기 접근

처음 문제를 풀었을 때, 간단한 그래프 탐색문제로 인지하고 "BFS"로 접근하여 풀었다. 
하지만 결과는.. 메모리 초과가 발생했고 틀렸다.

예제 입력으로 테스트해봐도 틀림이 없었고, 아무리 생각해도 도저히 틀린 이유를 알지 못했기 때문에
알고리즘 분류를 봤는데 DP가 들어가 있었다. 그리고 다시 문제를 보니 이제서야 이해가 되었다.

이 문제는 "메모이제이션"을 통해 탐색의 횟수를 줄여야 한다.

## 고민

BFS는 말 그대로 너비 탐색이다. 탐색 방법에 대해 조금만 생각해보면 
메모이제이션을 적용하는데 제약이 발생한다는 것을 알 수 있다.
쉽게 말해 뿌리는 내릴 때 한번에 모든 가지들을 내리며 탐색한다.
반대로 DFS는 가지를 내릴 때 끝까지 탐색하고 돌아온 다음 다음 가지를 탐색한다.
따라서 "선행"하는 탐색이 발생하고 이것을 통해 메모이제이션을 적용해준다면 불필요한
탐색을 제거할 수 있다. 

## 풀이

DFS 탐색 코드
```
static int dx[] = {0,1,0,-1};
    static int dy[] = {1,0,-1,0};
    private static int dfs(int x, int y){
        if(dp[x][y] != 0) return dp[x][y]; // A

        dp[x][y] = 1;

        for(int i = 0; i<4; i++){
            int nx = dx[i] + x;
            int ny = dy[i] + y;

            if(nx < 0 || ny < 0 || nx >= n || ny >= n) continue;
            if(board[nx][ny] <= board[x][y]) continue; // B

            dp[x][y] = Math.max(dp[x][y], dfs(nx,ny) + 1); // C

        }
        return dp[x][y]; // D
    }
```
dp[][]는 메모이제이션을 위한 이차원 배열이다. 그리고 문제에서 요구하는
판다가 이동할 수 있는 칸의 수의 최대값을 저장한다. 

쉽게 그림으로 예시를 들어 핵심만 설명해보겠다. 기본적인 것들(?)은 설명에서 배제한다.

* 기본적인 상황
![1937 BOJ](https://user-images.githubusercontent.com/53935439/153751172-4ee347c3-8a0d-4a74-a0e7-3866291df2eb.PNG)


* 메모이제이션이 활용된 상황
  ![1937 BOJ2](https://user-images.githubusercontent.com/53935439/153751329-7d9917f8-3d10-469e-a7be-b4b652005874.PNG)


