## 초기 접근

문제를 읽어보면 결국 사이클이 발생하는 경우에 그 인원들끼리 같은 프로젝트에 속하게 되고, 그 외 인원들의 수를 구해야 한다.

프로젝트 팀에 속하는 학생들의 수(cnt)를 구하면 n - cnt로 답을 구할 수 있다.

처음 생각은 어차피 1명의 학생이 고를 수 있는 학생의 수는 1명이기 떄문에 1차원 배열을 통해 1대 1매핑을 시켜주고 
DFS로 탐색을 해서 방문했던 노드를 다시 방문할 경우 사이클이 있다고 판단해서 개수를 반환하는 방식을 고려했는데,

그렇게 일일이 탐색을 모두 진행하면 최대 n이 100,000명이므로 대충 최악의 경우를 고려했을 때 100,000 * 100,000 을 해봐도
시간초과가 발생할 것이기 때문에 불가능했다.

그렇다면.. 먼저 탐색을 진행한 노드의 경우 다음부터 탐색을 하지 않도록 설계를 해야한다.

## 풀이

위의 생각에 기반해서 설계를 해보면 결국에 배열이 두 개 필요하다. 
* DFS 를 위한 배열(사이클 발견을 위한 배열)  - a
* 중복 탐색을 막기 위한 배열 - b

문제에서 들어준 예시를 들어 설명해보자면 다음과 같다.

n = 7

3 1 3 7 3 4 6

![image](https://user-images.githubusercontent.com/53935439/155655767-96ffd168-ada9-44ad-8e41-d593ec1a60df.png)

위와 같은 논리로 만든 DFS 코드는 아래와 같다.

```
    private static void dfs(int now) {
        if(visited[now]){
            // 한 사이클 돌고나면 들어올 수 있음
            finished[now] = true;
            cnt++;
        }else{
            visited[now] = true;
        }

        if(!finished[vote[now]]) dfs(vote[now]);

        // 한번 탐색했던 곳은 모두 finished처리, visited는 다음 탐색을 위해 초기화
        visited[now] = false;
        finished[now] = true;
    }
```
