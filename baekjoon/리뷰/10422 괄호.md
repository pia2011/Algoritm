## 접근

처음 문제를 봤을 땐 어떻게 풀어야할지 감이 잘 오지 않았다. 그래서 모든 경우의 수를 고려하고 
시뮬레이션으로 맞는지 판단해주면서 전체 개수를 구해야하는 문제로 인식하고 들여다 보았다. 근데 문자열의 길이가
최대 5000개 였다. 이걸 백트래킹으로 최적화를 시켜준다고 해도 정해진 시간(2s) 안에 해결할 수 있는지.. 확신이 서질 않았다.

때문에 규칙이 있는지 생각해 봤다. 하지만 규칙은 발견할 수 없었다... 대신 중복이 생기지 않는 패턴을 발견했고 조합+DP로 풀어야 한다는 것은 캐치할 수 있었다.

## 풀이

![image](https://user-images.githubusercontent.com/53935439/159337796-abe0247f-5284-499c-a9df-65133d3faf35.png)

모든 case는 위와 같은 조합으로 이루어 진다. 중복이 생길 수가 없다.(모든 케이스는 이 안에 겹치지 않게 포함된다) 

그렇다면 이 안에서 구성은 어떻게 될까?

![image](https://user-images.githubusercontent.com/53935439/159338321-f80a87e2-cd2a-408f-b9b6-bdadd5644e63.png)

위와 같이 된다. 각각

* 길이가 0인 올바른 괄호 * 길이가 4인 올바른 괄호
* 길이가 2인 올바른 괄호 * 길이가 2인 올바른 괄호
* 갤이가 4인 올바른 괄호 * 길이가 0인 올바른 괄호

로 나누어 볼 수 있다. 모두 더하면 길이가 6인 올바른 괄호의 개수가 되겠다. 그리고 당연히 이미 자리에 배치해 놓은 괄호 2개(붉은 색)는 제외해 주어야한다.

그렇다면 이제 2중 포문으로 점화식을 만들 수 있다.

```java
            for(int i = 2; i<=l; i+=2){
                for(int j = 2; j<=i; j+=2){
                    d[i] += d[j - 2] * d[i - j];
                    d[i] %= MOD;
                }
            }
```
